import math

import numpy as np
import scipy

from scipy.special import jv
import torch

# movies configuration
run_movies_ALL_VCSELs_with_phase_mask = True  # run movie with MPLC
run_movie_only_lens = True  # run movie No MPLC

# plot figures config
plot_vcsels = True
plot_micro_lens = True
plot_epoch_vs_eff = True
plot_phase_masks = True
plot_coupling_matrix = True
plot_IL_each_vcsel = True
plot_VCSEL_to_MODE_IL = True
plot_fiber_mode = False

vcsel_groups = 3  # Define how many radius of VCSELs sources exist.
vcsel_num = 19  # This number must match the number of VCSEL generated by the VCSEL_groups.
grid = 'TRIANGLE'
vcsel_on_center = True
gaus_source_waist = 2e-6  # radius
planes_num = 3  # Number of phase masks
f_micro_lens = 48e-6
f_big_lens = 300
# space_between_lens = f_micro_lens + f_big_lens
space_between_lens = 20e-6
space_between_planes = f_big_lens / (planes_num + 1)
pitch = 40e-6
frame_size = 300e-6
print("frame size", frame_size)
res = 512
div_res = 4
pixel_size = frame_size / res
print("pixel size", pixel_size)


iterations_length = 50  # num of iterations.
big_lens_size = frame_size
micro_lens_size = pitch
lr = 50  # learning rate.
WL = 940e-9  # Wavelength.

# index
air = 1
glass = 1.5
photo_polymer = 1.53

# fiber parameters
d_core, d_clad = 10e-6, 20e-6
print("diameter fiber core", d_core)
print("diameter fiber clad", d_clad)
a_core, a_clad = d_core / 2, d_clad / 2
n_core, n_clad = 1.44861, 1.44428
# NA = np.sqrt(n_core ** 2 - n_clad ** 2)
NA = 0.2
v = (2 * np.pi * a_core / WL) * NA
M_square = (v ** 2) / 2
print("number of modes in the fiber - ", int(M_square))

fiber_mode_number_list = range(1, vcsel_num+1)

fiber_res = int((d_clad / frame_size) * res)

# video parameters
div_frame = 20
plane_delay = 8
fps = 8

cover_glass_space = 130e-6

xs_frame = (frame_size / 2) * torch.linspace(-1, 1, res)
ys_frame = xs_frame
[xx_frame, yy_frame] = torch.meshgrid(xs_frame, ys_frame)
rr_frame = np.sqrt(xx_frame ** 2 + yy_frame ** 2)
frame_zero1 = abs(xx_frame) < (frame_size / 2)
frame_zero2 = abs(yy_frame) < (frame_size / 2)
frame_zero = frame_zero1 * frame_zero2
point_fiber = rr_frame <= a_clad

eff_each_movie_list_part1_db = np.zeros((2, vcsel_num), dtype=np.float64)
eff_each_movie_list_part2_db = np.zeros((2, vcsel_num), dtype=np.float64)
eff_list_part1 = np.zeros((vcsel_num, iterations_length))
eff_list_part2 = np.zeros((vcsel_num, iterations_length))
eff_list = np.zeros((vcsel_num, iterations_length))
eff_each_movie_list_db = np.zeros((vcsel_num, iterations_length))

#########################
### for gen_fiber_mode ##
#########################
matrix_of_bessel_zeros = np.zeros((50, 50), dtype=float)
U = torch.arange(0.1, v, 0.1)
for j in range(50):
    x_cut = scipy.special.jn_zeros(j, 50)
    matrix_of_bessel_zeros[j, 0: len(x_cut)] = x_cut

new_mat = np.zeros((3, int(len(matrix_of_bessel_zeros)**2)))
new_list_count = 0
for i in range(len(matrix_of_bessel_zeros)):
    for j in range(len(matrix_of_bessel_zeros)):
        new_mat[0, new_list_count], new_mat[1, new_list_count], new_mat[2, new_list_count] = matrix_of_bessel_zeros[i,j], i, j
        new_list_count += 1

min_val = 100
sort_mat_count = 0
sort_mat = np.zeros((3, len(new_mat[0])*2))
for i in range(len(new_mat[0])):
    for j in range(len(new_mat[0])):
        if ((new_mat[0, j]) < min_val) and ((new_mat[0, j]) not in sort_mat[0]):
            min_val, min_i, min_j = new_mat[0, j], new_mat[1, j], new_mat[2, j]
    sort_mat[0, sort_mat_count], sort_mat[1, sort_mat_count], sort_mat[2, sort_mat_count] = min_val, min_i, min_j+1
    sort_mat_count += 1
    if (min_i != 0):
        sort_mat[0, sort_mat_count], sort_mat[1, sort_mat_count], sort_mat[2, sort_mat_count] = min_val, min_i, min_j+1
        sort_mat_count += 1
    min_val = 100


